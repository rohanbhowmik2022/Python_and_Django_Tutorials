SQL Databases -> Structured, relational, strict rules
NoSQL Databases -> Flexible, Scalable, Schema-less (or semi structured)

| Feature        | SQL                     | NoSQL                      |
| -------------- | ----------------------- | -------------------------- |
| Data structure | Tables (rows & columns) | JSON, documents, key-value |
| Schema         | Fixed                   | Flexible                   |
| Scalability    | Vertical                | Horizontal                 |
| Relationships  | Strong (JOINs)          | Limited or manual          |
| Transactions   | ACID                    | BASE (mostly)              |
| Best for       | Banking, ERP            | Big data, real-time apps   |

Real World Analogy

SQL -> Bank Ledger (Strict, accurate)
NoSQL -> WhatsApp Chats (fast, flexible)

Tables, Rows, Columns & Keys (SQL Basics)

A table stores data about one entity.
Example: users

Row (Record)
--------------
One row = one real-world object

id | name  | email
1  | Rohan | r@example.com

Column (Field)
--------------
One column = one property
1. id
2. name
3. email

Keys (Very Important)
----------------------

1ï¸âƒ£ Primary Key
Uniquely identifies a row
Cannot be NULL or duplicate
id = 1

2ï¸âƒ£ Foreign Key
Creates relationship between tables
orders.user_id â†’ users.id
ğŸ“Œ This enforces data integrity

3ï¸âƒ£ Unique Key
No duplicates (email, phone number)


<<<NoSQL Data Model (Simple)>>>

Example Document
{
  "id": 1,
  "name": "Rohan",
  "orders": [
    {"product": "Laptop", "price": 70000}
  ]
}

Benefits
--------
âœ” No JOIN
âœ” Everything together
âœ” Faster reads

What is ORM?
ORM lets you interact with the database using objects instead of SQL queries.

Without ORM
SELECT * FROM users WHERE id = 1;

With ORM
user = User.objects.get(id=1)

How ORM Works Internally
Class â†’ Table
Object â†’ Row
Attribute â†’ Column


> Benefits of ORM
| Benefit         | Why it matters         |
| --------------- | ---------------------- |
| Less SQL        | Cleaner code           |
| DB-agnostic     | Switch DB easily       |
| Security        | Prevents SQL injection |
| Productivity    | Faster development     |
| Maintainability | Easier refactoring     |


Popular ORMs:

1. Django ORM
2. SQLAlchemy
3. Hibernate

6ï¸âƒ£ ORM Trade-offs (Important for Interviews)

âŒ Slower for complex queries
âŒ Less control than raw SQL
âŒ Can cause N+1 query problems

ğŸ‘‰ Best practice: ORM + raw SQL when needed

ACID Properties
-------------------
A - Atomicity -> The entire transaction takes place at once or doesn't happen at all
C - Consistency -> The database must be consistent before and after the transaction
I - Isolation -> Multiple Transactions occur independently without interference
D - Durability -> The changes of a successful transaction occurs even if the system failure occurs

It ensures reliable transactions in SQL databases

A - Atomicity (All or Nothing)
Example - Rs 100 Debited and Rs 100 Credited > If credit fails -> Debit rolls back

C - Consistency (Database rules are never broken)
Example - Balance cannot be negative, Foreign Keys must exist

I - Isolation (Transactions don't interfere)
Example - Two users withdrawing money, Each transaction sees correct balance

D - Durability (Once committed, data is permanent)
Example - Even if server crashes..Transaction remains saved

| ACID (SQL)         | BASE (NoSQL)            |
| ------------------ | ----------------------- |
| Strong consistency | Eventual consistency    |
| Reliable           | Highly scalable         |
| Slower             | Faster                  |
| Banking systems    | Social media, analytics |


When to Use What (Practical Guidance)
âœ… Use SQL when:

1. Financial systems
2. Inventory management
3. Relationships matter
4. ACID compliance needed

âœ… Use NoSQL when:

1. Massive scale
2. Flexible data
3. Real-time analytics
4. IoT / chat apps

SQL = Structure + Accuracy + Relationships
NoSQL = Flexibility + Speed + Scale
ORM = Bridge between code & database
ACID = Trust in data


Design DB schema for a blog system
-----------------------------------

1ï¸âƒ£ Users Table
Purpose

Stores authors and readers.

users
-----
id (PK)
username (UNIQUE)
email (UNIQUE)
password_hash
role        -- admin / author / reader
created_at
updated_at

Why?

One user can write many posts

One user can write many comments

ğŸ‘‰ One-to-Many relationship with posts & comments

2ï¸âƒ£ Posts Table
Purpose

Stores blog articles.

posts
-----
id (PK)
title
slug (UNIQUE)
content
author_id (FK â†’ users.id)
status        -- draft / published
published_at
created_at
updated_at

Key Points

slug â†’ SEO-friendly URLs

status â†’ supports drafts

author_id â†’ Foreign Key

ğŸ“Œ One user â†’ many posts

3ï¸âƒ£ Categories Table
Purpose

High-level grouping (Tech, DevOps, AI)

categories
----------
id (PK)
name (UNIQUE)
slug (UNIQUE)
created_at

4ï¸âƒ£ Post-Category Mapping (Many-to-Many)

A post can have multiple categories.

post_categories
---------------
post_id (FK â†’ posts.id)
category_id (FK â†’ categories.id)
PRIMARY KEY (post_id, category_id)


ğŸ“Œ This avoids duplication and keeps schema normalized.

5ï¸âƒ£ Tags Table
Purpose

Fine-grained labels (django, sql, rest)

tags
----
id (PK)
name (UNIQUE)
slug (UNIQUE)

6ï¸âƒ£ Post-Tag Mapping (Many-to-Many)
post_tags
---------
post_id (FK â†’ posts.id)
tag_id (FK â†’ tags.id)
PRIMARY KEY (post_id, tag_id)

7ï¸âƒ£ Comments Table
Purpose

User feedback on posts.

comments
--------
id (PK)
post_id (FK â†’ posts.id)
user_id (FK â†’ users.id)
parent_id (FK â†’ comments.id, NULLABLE)
content
created_at

Why parent_id?

Enables nested comments / replies

ğŸ“Œ Self-referencing foreign key = threaded comments

8ï¸âƒ£ Likes Table
Purpose

Track likes on posts.

likes
-----
id (PK)
post_id (FK â†’ posts.id)
user_id (FK â†’ users.id)
created_at
UNIQUE (post_id, user_id)


âœ” Prevents double-likes
âœ” Simple & scalable

ğŸ”— Relationships Summary
Relationship	Type
User â†’ Posts	One-to-Many
User â†’ Comments	One-to-Many
Post â†’ Comments	One-to-Many
Post â†’ Categories	Many-to-Many
Post â†’ Tags	Many-to-Many
Post â†’ Likes	One-to-Many
Comment â†’ Comment	Self-referencing
ğŸ§  ACID-Safe & Normalized Design

âœ… No duplicate data

âœ… Strong referential integrity

âœ… Easy to scale

âœ… ORM-friendly

ğŸ§‘â€ğŸ’» ORM Mapping (Django-Style Example)
class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    categories = models.ManyToManyField(Category)
    tags = models.ManyToManyField(Tag)


ğŸ“Œ ORM automatically creates:

Join tables

Foreign keys

Indexes

ğŸš€ Optional Advanced Add-Ons

If you want industry-level design:

post_views table (analytics)

soft_delete flags

post_versions (edit history)

is_featured boolean

published_by admin FK

ğŸ§  Final Mental Model
Users write Posts
Posts have Categories & Tags
Users comment & like Posts
Everything is connected via keys
